#test the time of each algorithm with initial states that generated by randomly moving limited steps from the goal state
#the depth of the optimal path is less than or equal to the limit
#with the limit small enough, for most algorithms the searching can be finished quickly

import search as s
import testgraphs as t
import random as rd
import time

def goal(n):
    """
    get the goal state with given n
    """
    result = list(range(1, n**2))
    result.append(0)
    result = t.State(result)
    return result

limit = 20
maxn = 12
search_methods = [s.BFS, s.UCS, s.DFS, s.DLS, s.IDS, s.Astar, s.MCTSSearch]
name = ["BFS","UCS","DFS","DLS","IDS","A*","MCTS"]
n = 3
jump = [True, True, True, False, True, True, True]
#control which methods are to be ignored
#to be ignored if True

next_round = True

while next_round and n < maxn:
    
    graph = t.nPuzzleGraph(n)
    states = list(range(5))

    for j in range(5):
        states[j] = goal(n)
        for i in range(limit):
            states[j] = rd.choice([choice[1] for choice in graph.successors(states[j])]) 
            #get 5 initial states within limit steps from the goal
        
        print("state ",j,": ", states[j])
    
    for j in range(7):
        cost_time = 0
        if jump[j]:
            continue
            
        print(name[j])
        for i in range(5):
            initialState = states[i]
            graph.setInitialState(initialState)
            time_start=time.time()
            result = search_methods[j](graph,initialState)
            time_end=time.time()
            if result:
                print('State ', i,' time cost:',time_end-time_start,'s')
            else: 
                print("Fail")
            
            if (time_end-time_start) > 3600 or (not result):
                jump[j] = True
                break
            else:
                cost_time += time_end-time_start
    
        if not jump[j]:
            cost_time /= 5
            print("Average time cost: ", cost_time,'s')
            if cost_time > 1800:
                jump[j] = True
        else:
            print("NA")
    
    next_round = False
    for j in jump:
        if not j:
            next_round = True
    n += 2
